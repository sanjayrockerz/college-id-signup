# PgBouncer Configuration for Production-Scale Connection Pooling
# Version: 1.0.0
# Purpose: Transaction pooling to stabilize backend connections under high concurrency

[databases]
# Production database routing (update with actual credentials)
chat_prod = host=postgres port=5432 dbname=chat_prod user=chat_user password=REPLACE_WITH_PASSWORD

# Performance test environments
chat_perf_dev = host=postgres port=5432 dbname=chat_perf_dev user=perf_dev_user password=REPLACE_WITH_PASSWORD
chat_perf_staging = host=postgres port=5432 dbname=chat_perf_staging user=perf_staging_user password=REPLACE_WITH_PASSWORD
chat_perf = host=postgres port=5432 dbname=chat_perf user=perf_user password=REPLACE_WITH_PASSWORD

# Alias for easy routing (use in DATABASE_URL)
* = host=postgres port=5432

[pgbouncer]
###############################################################################
# POOLING CONFIGURATION
###############################################################################

# Pool mode: transaction (recommended for most apps)
# - Each client connection uses a backend connection only during transactions
# - Server connection released immediately after COMMIT/ROLLBACK
# - Allows high connection counts on app side with few backend connections
pool_mode = transaction

# Connection limits per database
# Target: Keep total backend connections < PostgreSQL max_connections (typically 100-200)
# Formula: (max_db_connections * num_databases) < postgres_max_connections * 0.8
default_pool_size = 20          # Backend connections per database (idle + active)
min_pool_size = 10              # Minimum connections to maintain (reduces latency spikes)
reserve_pool_size = 5           # Emergency connections for high-priority clients
reserve_pool_timeout = 3        # Seconds to wait for reserve pool

# Client connection limits
# This is your app-side connection burst capacity
max_client_conn = 10000         # Maximum concurrent client connections
max_db_connections = 100        # Total backend connections across all databases
max_user_connections = 1000     # Per-user connection limit

###############################################################################
# QUEUE MANAGEMENT
###############################################################################

# Queue wait time - CRITICAL METRIC for stability
# Target: Keep db_tx_queue_wait_ms bounded at 5k-10k connections
server_idle_timeout = 600       # Close idle backend connections after 10 minutes
server_lifetime = 3600          # Recycle backend connections after 1 hour (prevents leaks)
server_connect_timeout = 15     # Timeout for establishing backend connections
server_login_retry = 15         # Retry delay for failed backend connections

# Client timeouts
client_idle_timeout = 0         # Keep client connections open (let app manage)
query_timeout = 120             # Abort queries running longer than 2 minutes
query_wait_timeout = 120        # Max wait time in queue before aborting

# Transaction limits
server_check_delay = 30         # Check server health every 30 seconds
server_check_query = SELECT 1   # Health check query

###############################################################################
# PERFORMANCE TUNING
###############################################################################

# TCP settings
tcp_keepalive = 1               # Enable TCP keepalive
tcp_keepcnt = 5                 # Number of keepalive probes
tcp_keepidle = 30               # Idle time before first probe
tcp_keepintvl = 10              # Interval between probes

# Protocol optimizations
pkt_buf = 8192                  # Packet buffer size (default is fine)
listen_backlog = 4096           # TCP listen queue size (handle connection bursts)

# Authentication
auth_type = scram-sha-256       # Secure authentication (or md5 if using older Postgres)
auth_file = /etc/pgbouncer/userlist.txt
auth_user = pgbouncer           # Admin user for auth queries
auth_query = SELECT usename, passwd FROM pg_shadow WHERE usename=$1

###############################################################################
# LOGGING & MONITORING
###############################################################################

# Admin interface (for metrics collection)
admin_users = pgbouncer_admin
stats_users = pgbouncer_stats

# Logging
logfile = /var/log/pgbouncer/pgbouncer.log
pidfile = /var/run/pgbouncer/pgbouncer.pid
log_connections = 1             # Log all connections (debugging)
log_disconnections = 1          # Log disconnections
log_pooler_errors = 1           # Log pooling errors
log_stats = 1                   # Log statistics
stats_period = 60               # Log stats every 60 seconds

# Verbose logging for troubleshooting (disable in production)
verbose = 0                     # Set to 1 for debugging

###############################################################################
# ADVANCED SETTINGS
###############################################################################

# Connection string parameters that can be set by client
ignore_startup_parameters = extra_float_digits,application_name

# Security
unix_socket_dir = /var/run/postgresql
unix_socket_mode = 0777
unix_socket_group = postgres

# Listen address
listen_addr = 0.0.0.0
listen_port = 6432              # PgBouncer listens on 6432 (Postgres on 5432)

# Application name for tracking
application_name_add_host = 1   # Append hostname to application_name

###############################################################################
# TUNING MATRIX (Load-based configuration)
###############################################################################

# Low Load (< 1000 concurrent connections)
# - default_pool_size = 10
# - max_client_conn = 1000
# - Expected queue wait: < 10ms

# Medium Load (1000-5000 concurrent connections)
# - default_pool_size = 20 (current setting)
# - max_client_conn = 5000
# - Expected queue wait: 10-50ms

# High Load (5000-10000 concurrent connections)
# - default_pool_size = 30
# - max_client_conn = 10000
# - Expected queue wait: 50-200ms
# - Monitor: If queue wait > 500ms, increase pool_size or scale horizontally

# Saturation Threshold (Rollback Trigger)
# - If db_tx_queue_wait_ms > 1000ms for p95
# - If backend connection errors > 1% of requests
# - If transaction_duration increases > 50% from baseline
# â†’ ROLLBACK to direct database connection

###############################################################################
# HEALTH CHECK QUERIES
###############################################################################

# Use these queries to monitor PgBouncer health:
#
# 1. Show pool status:
#    SHOW POOLS;
#
# 2. Show client connections:
#    SHOW CLIENTS;
#
# 3. Show server connections:
#    SHOW SERVERS;
#
# 4. Show statistics:
#    SHOW STATS;
#
# 5. Show configuration:
#    SHOW CONFIG;
#
# 6. Show wait time stats:
#    SHOW STATS_TOTALS;

###############################################################################
# ROLLBACK PLAN
###############################################################################

# If PgBouncer causes issues:
#
# 1. Quick rollback (< 5 minutes):
#    - Update DATABASE_URL to bypass PgBouncer (point directly to postgres:5432)
#    - Restart app instances (rolling restart to avoid downtime)
#    - Monitor direct connection count (ensure < max_connections)
#
# 2. Gradual rollback (canary):
#    - Route 10% traffic through direct connection
#    - Compare metrics: latency, error rate, connection count
#    - If metrics improve, continue gradual rollback
#    - If metrics degrade, keep PgBouncer and investigate root cause
#
# 3. Emergency circuit breaker:
#    - Set ENABLE_PGBOUNCER=false environment variable
#    - App automatically switches to direct connection
#    - Requires app code support (see Prisma integration)
